const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
puppeteer.use(StealthPlugin());
const fs = require('fs-extra');
const path = require('path');
const UserAgent = require('user-agents');

const cookieManager = require('./cookieManager');
const humanBehavior = require('./humanBehavior');
const priceCalculator = require('../utils/priceCalculator');
const logger = require('../utils/logger');

class Chrono24Service {
  constructor() {
    this.browser = null;
    this.page = null;
    this.isLoggedIn = false;
    this.lastActivity = Date.now();
    this.sessionTimeout = parseInt(process.env.SESSION_TIMEOUT_MS) || 300000; // 5 minutes
  }

  async initialize() {
    if (this.browser && !this.browser.isConnected()) {
      await this.cleanup();
    }

    if (!this.browser) {
      logger.info('Initializing Puppeteer browser');

      // Use exact Chrome UA and fingerprint from HAR
      const chromeUA =
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36';
      const secChUa = '"Not;A=Brand";v="99", "Google Chrome";v="139", "Chromium";v="139"';
      const secChUaMobile = '?0';
      const secChUaPlatform = '"Windows"';
      // FIX: Remove zstd - it's not used by real browsers and flags bot traffic
      const acceptEncoding = 'gzip, deflate, br';
      const priority = 'u=0, i';

      // Randomize viewport
      const viewportWidth = 1400 + Math.floor(Math.random() * 100) - 50;
      const viewportHeight = 900 + Math.floor(Math.random() * 100) - 50;

      const launchOptions = {
        headless: 'new',
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-blink-features=AutomationControlled',
          '--disable-extensions',
          '--no-first-run',
          '--disable-default-apps',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--no-zygote',
          '--single-process',
          '--disable-background-timer-throttling',
          '--disable-backgrounding-occluded-windows',
          '--disable-renderer-backgrounding',
          // FIX: Add more stealth flags to avoid detection
          '--disable-features=VizDisplayCompositor',
          '--disable-ipc-flooding-protection',
          '--enable-features=NetworkService,NetworkServiceLogging',
          '--force-color-profile=srgb',
          '--metrics-recording-only',
          '--use-mock-keychain',
          // Turnstile-specific optimizations
          '--disable-web-security',
          '--disable-features=TranslateUI',
          '--disable-component-extensions-with-background-pages',
          '--disable-background-timer-throttling',
          '--disable-renderer-backgrounding',
          '--disable-backgrounding-occluded-windows',
          '--disable-field-trial-config',
          '--disable-hang-monitor',
          '--allow-running-insecure-content',
          '--enable-unsafe-webgpu',
          `--window-size=${viewportWidth},${viewportHeight}`,
          `--user-agent=${chromeUA}`,
        ],
        defaultViewport: {
          width: viewportWidth,
          height: viewportHeight,
        },
        ignoreDefaultArgs: ['--enable-automation'],
      };

      // Set Chrome executable path based on environment
      if (process.env.CHROME_EXECUTABLE_PATH) {
        launchOptions.executablePath = process.env.CHROME_EXECUTABLE_PATH;
      } else if (process.env.NODE_ENV === 'production') {
        launchOptions.executablePath = '/usr/bin/google-chrome-stable';
      }

      this.browser = await puppeteer.launch(launchOptions);
      this.page = await this.browser.newPage();

      // Enhanced stealth setup - mimic real browser environment more closely
      await this.page.evaluateOnNewDocument(() => {
        // Remove webdriver traces
        Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
        delete navigator.__proto__.webdriver;

        // Mock realistic plugins
        Object.defineProperty(navigator, 'plugins', {
          get: () => [
            { name: 'Chrome PDF Plugin', description: 'Portable Document Format' },
            { name: 'Chrome PDF Viewer', description: 'PDF Viewer' },
            { name: 'Native Client', description: 'Native Client' },
          ],
        });

        // Set realistic languages
        Object.defineProperty(navigator, 'languages', {
          get: () => ['en-US', 'en'],
        });

        // Add chrome runtime object
        Object.defineProperty(window, 'chrome', {
          writable: true,
          enumerable: true,
          configurable: false,
          value: {
            runtime: {},
            loadTimes: function () {},
            csi: function () {},
          },
        });

        // Override permissions API to avoid detection
        const originalQuery = window.navigator.permissions.query;
        window.navigator.permissions.query = (parameters) =>
          parameters.name === 'notifications'
            ? Promise.resolve({ state: Notification.permission })
            : originalQuery(parameters);

        // FIX: Add more realistic browser properties
        Object.defineProperty(navigator, 'hardwareConcurrency', {
          get: () => 4,
        });
        Object.defineProperty(navigator, 'deviceMemory', {
          get: () => 8,
        });
        Object.defineProperty(screen, 'colorDepth', {
          get: () => 24,
        });

        // Mock connection info to look more realistic
        Object.defineProperty(navigator, 'connection', {
          get: () => ({
            effectiveType: '4g',
            rtt: 100,
            downlink: 2,
          }),
        });
      });

      // Set extra headers to match HAR (with corrected accept-encoding)
      await this.page.setExtraHTTPHeaders({
        Accept:
          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
        'Accept-Encoding': acceptEncoding, // Now uses 'gzip, deflate, br' without zstd
        'Accept-Language': 'en-US,en;q=0.9',
        'Cache-Control': 'no-cache',
        Pragma: 'no-cache',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none', // Will be updated per request
        'Sec-Fetch-User': '?1',
        'Upgrade-Insecure-Requests': '1',
        'sec-ch-ua': secChUa,
        'sec-ch-ua-mobile': secChUaMobile,
        'sec-ch-ua-platform': secChUaPlatform,
        Priority: priority,
      });

      // Set viewport
      await this.page.setViewport({
        width: viewportWidth,
        height: viewportHeight,
        hasTouch: false,
        isLandscape: true,
        deviceScaleFactor: 1,
      });

      // Load cookies before navigation
      await cookieManager.loadCookies(this.page);

      // CRITICAL FIX: Minimal request interception to avoid CORS/OPTIONS issues
      // Only log requests, don't modify headers extensively to avoid bot detection
      const BOT_LOG_PATH = path.join(__dirname, '../logs/bot_network.log');

      // Clear previous logs for clean analysis
      try {
        fs.writeFileSync(BOT_LOG_PATH, '');
        logger.info('Cleared bot network logs for fresh capture');
      } catch (err) {
        logger.warn(`[BOT LOG CLEAR ERROR] ${err.message}`);
      }

      await this.page.setRequestInterception(true);
      this.page.on('request', (request) => {
        const method = request.method();
        const url = request.url();
        const resourceType = request.resourceType();

        // Block or redirect OPTIONS requests that would trigger 405 errors
        if (method === 'OPTIONS') {
          // Log blocked OPTIONS request
          logger.info(`[BLOCKED OPTIONS] ${url}`);
          try {
            const event = {
              type: 'request_blocked',
              method: 'OPTIONS',
              url: url,
              reason: 'Preventing 405 error from CORS preflight',
              timestamp: Date.now(),
            };
            fs.appendFileSync(BOT_LOG_PATH, JSON.stringify(event) + '\n');
          } catch (err) {
            logger.warn(`[BOT LOG ERROR] ${err.message}`);
          }
          // Block OPTIONS request to prevent 405 errors
          request.abort('blockedbyclient');
          return;
        }

        // Only log for debugging - minimal header modification
        const event = {
          type: 'request',
          method: request.method(),
          url: request.url(),
          headers: request.headers(),
          postData: request.postData() || null,
          timestamp: Date.now(),
        };
        try {
          fs.appendFileSync(BOT_LOG_PATH, JSON.stringify(event) + '\n');
        } catch (err) {
          logger.warn(`[BOT LOG ERROR] ${err.message}`);
        }
        logger.info(`[REQUEST] ${request.method()} ${request.url()}`);

        // Only modify headers for main document requests to avoid triggering CORS preflight
        if (resourceType === 'document') {
          const headers = { ...request.headers() };

          // Remove headers that could trigger preflight OPTIONS requests
          delete headers['access-control-request-method'];
          delete headers['access-control-request-headers'];
          delete headers['origin'];

          // Continue with modified headers for document requests
          request.continue({ headers });
        } else {
          // Let all other requests (CSS, JS, images, etc.) pass through completely unchanged
          // This prevents triggering CORS preflight for static resources
          request.continue();
        }
      });
      this.page.on('response', async (response) => {
        try {
          const event = {
            type: 'response',
            status: response.status(),
            url: response.url(),
            headers: response.headers(),
            timestamp: Date.now(),
          };
          fs.appendFileSync(BOT_LOG_PATH, JSON.stringify(event) + '\n');
          const headers = response.headers();
          const status = response.status();
          const url = response.url();
          logger.info(`[RESPONSE] ${status} ${url}`);
          logger.debug(`[RESPONSE HEADERS] ${JSON.stringify(headers)}`);
          if (headers['content-type'] && headers['content-type'].includes('text/html')) {
            const body = await response.text();
            logger.debug(`[RESPONSE BODY] ${url} ${body.slice(0, 500)}`); // Truncated
          }
        } catch (e) {
          logger.warn(`[RESPONSE ERROR] ${e.message}`);
        }
      });

      logger.info('Page setup completed with enhanced anti-bot measures and network logging');
    }
  }

  async setupPage() {
    // Remove webdriver property
    await this.page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, 'webdriver', {
        get: () => undefined,
      });
    });

    // Override the plugins property to use a custom getter
    await this.page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, 'plugins', {
        get: () => [1, 2, 3, 4, 5],
      });
    });

    // Override the languages property to use a custom getter
    await this.page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, 'languages', {
        get: () => ['en-US', 'en'],
      });
    });

    // Set realistic desktop viewport
    await this.page.setViewport({
      width: 1400,
      height: 900,
      hasTouch: false,
      isLandscape: true,
    });

    // Set extra headers
    await this.page.setExtraHTTPHeaders({
      Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
      'Accept-Encoding': 'gzip, deflate, br',
      'Accept-Language': 'en-US,en;q=0.9',
      'Cache-Control': 'no-cache',
      Pragma: 'no-cache',
      'Sec-Fetch-Dest': 'document',
      'Sec-Fetch-Mode': 'navigate',
      'Sec-Fetch-Site': 'none',
      'Upgrade-Insecure-Requests': '1',
    });

    // Load existing cookies if available
    await cookieManager.loadCookies(this.page);

    logger.info('Page setup completed with anti-bot measures');
  }

  async ensureLoggedIn() {
    if (this.isLoggedIn && Date.now() - this.lastActivity < 30 * 60 * 1000) {
      return true;
    }

    try {
      // Try to restore session from cookies first
      const cookies = await cookieManager.loadCookies();
      if (cookies && cookies.length > 0) {
        await this.page.setCookie(...cookies);
        await this.page.goto('https://www.chrono24.com/user/', {
          waitUntil: 'domcontentloaded',
          timeout: 30000,
        });

        try {
          await this.page.waitForSelector('a[href*="/user/"]', { timeout: 5000 });
          logger.info('Successfully restored session from cookies');
          this.isLoggedIn = true;
          this.lastActivity = Date.now();
          return true;
        } catch (e) {
          logger.info('Cookies invalid, proceeding with collection page check');
        }
      }

      // Follow the correct workflow: Try collection page first, only login if redirected
      logger.info('Checking authentication status via collection page');
      const collectionUrl = 'https://www.chrono24.com/user/watch-collection/product-suggestions.htm?watchCollectionItemOrigin=WatchCollection';
      
      await this.page.goto(collectionUrl, {
        waitUntil: 'domcontentloaded',
        timeout: 30000,
      });

      // Wait a moment for potential redirect
      await humanBehavior.randomDelay(1000, 2000);
      
      const currentUrl = this.page.url();
      logger.info(`After collection page navigation, current URL: ${currentUrl}`);
      
      // Check if we're redirected to login page
      if (currentUrl.includes('/auth/login')) {
        logger.info('Redirected to login page, authentication required');

      logger.info('Login form detected, performing login');

      // Handle Turnstile CAPTCHA if present
      await this.handleTurnstileCaptcha();

      // Human-like random delay
      await humanBehavior.randomDelay();

      // Simulate human behavior before filling form
      const viewport = await this.page.viewport();
      await this.page.mouse.move(Math.random() * viewport.width, Math.random() * viewport.height);
      await humanBehavior.randomDelay();

      // Validate credentials before attempting login
      if (!process.env.CHRONO24_EMAIL || !process.env.CHRONO24_PASSWORD) {
        throw new Error('CHRONO24_EMAIL and CHRONO24_PASSWORD environment variables must be set');
      }

      // Fill email field with human-like typing
      await humanBehavior.humanType(this.page, '#email', process.env.CHRONO24_EMAIL);
      await humanBehavior.randomDelay();

      // Check for email validation
      try {
        await this.page.waitForSelector('.js-email-validation-error', { timeout: 2000 });
        throw new Error('Invalid email format detected');
      } catch (e) {
        // No error is good - email is valid
      }

      // Fill password field with human-like typing
      await humanBehavior.humanType(this.page, '#password', process.env.CHRONO24_PASSWORD);
      await humanBehavior.randomDelay();

      // Optional: Check remember me
      const rememberCheckbox = await this.page.$('#userLogInPermanently');
      if (rememberCheckbox) {
        const isChecked = await this.page.$eval('#userLogInPermanently', (el) => el.checked);
        if (!isChecked) {
          await humanBehavior.humanClick(this.page, '#userLogInPermanently');
          await humanBehavior.randomDelay();
        }
      }

      // Handle Turnstile CAPTCHA before clicking login button
      await this.handleTurnstileCaptcha();

      // Random mouse movement
      await this.page.mouse.move(Math.random() * viewport.width, Math.random() * viewport.height);
      await humanBehavior.randomDelay();

      // Click login button
      await humanBehavior.humanClick(this.page, '.js-login-button');

      // Wait for Turnstile challenge to complete if present
      await this.waitForTurnstileCompletion();

      // Wait longer for potential redirects after Turnstile completion
      logger.info('Waiting for login processing after Turnstile completion...');
      await humanBehavior.randomDelay(8000, 12000);

      // Try to wait for either successful login or error state
      try {
        logger.info('Waiting for login success indicators or form disappearance...');

        // First, wait specifically for the most reliable indicator: URL change or form disappearance
        const loginSuccess = await Promise.race([
          // Primary indicator: URL no longer contains login path
          this.page
            .waitForFunction(() => !window.location.href.includes('/auth/login'), { timeout: 15000 })
            .then(() => 'url_changed'),
          // Secondary indicator: login form elements disappear completely
          this.page
            .waitForFunction(
              () => {
                const email = document.querySelector('#email');
                const password = document.querySelector('#password');
                const loginButton = document.querySelector('.js-login-button');
                return !email || !password || !loginButton;
              },
              { timeout: 15000 },
            )
            .then(() => 'form_disappeared'),
          // Tertiary: explicit success elements appear AND form is gone
          this.page
            .waitForFunction(
              () => {
                const hasSuccessIndicators = document.querySelector(
                  'a[href*="/user/"], .user-menu, [data-testid="user-menu"], .js-user-menu',
                );
                const hasLoginForm = document.querySelector('#email, #password, .js-login-button');
                return hasSuccessIndicators && !hasLoginForm;
              },
              { timeout: 15000 },
            )
            .then(() => 'success_elements_with_no_form'),
        ]);

        logger.info(`Login success detected via: ${loginSuccess}`);
      } catch (e) {
        logger.warn('No immediate success indicators detected, continuing with error checking...');
      }

      // Additional check: Log current URL and page state for debugging
      const currentPageUrl = this.page.url();
      const hasLoginForm = (await this.page.$('#email')) && (await this.page.$('#password'));
      logger.info(`Current URL: ${currentPageUrl}, Has login form: ${hasLoginForm}`);

      // Enhanced final validation: Check multiple indicators
      const isStillOnLoginPage = currentPageUrl.includes('/auth/login');
      const hasEmailField = !!(await this.page.$('#email'));
      const hasPasswordField = !!(await this.page.$('#password'));
      const hasLoginButton = !!(await this.page.$('.js-login-button'));

      logger.info(
        `Final validation - URL contains login: ${isStillOnLoginPage}, Email field: ${hasEmailField}, Password field: ${hasPasswordField}, Login button: ${hasLoginButton}`,
      );

      // Consider login failed only if we're still on login page AND have login form elements
      const loginFormPresent = hasEmailField && hasPasswordField && hasLoginButton;

      if (isStillOnLoginPage && loginFormPresent) {
        logger.warn('Login validation: Still on login page with form elements present');

        // Check for specific error messages
        const errorElements = await this.page.$$('.error-message, .alert-danger, .js-login-error');
        if (errorElements.length > 0) {
          const errorText = await this.page.evaluate(() => {
            const errors = document.querySelectorAll('.error-message, .alert-danger, .js-login-error');
            return Array.from(errors)
              .map((el) => el.textContent.trim())
              .join('; ');
          });
          throw new Error(`Login failed with error: ${errorText}`);
        }

        // Check if Turnstile is actively challenging (more specific check)
        const isTurnstileActive = await this.page.evaluate(() => {
          // Look for active Turnstile challenge indicators
          const turnstileFrames = document.querySelectorAll('iframe[src*="turnstile"]');
          for (const frame of turnstileFrames) {
            // Check if the frame is visible and actively showing a challenge
            const rect = frame.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              // Check if parent has error states or challenge states
              const parent = frame.closest('.cf-turnstile');
              if (parent) {
                const style = window.getComputedStyle(parent);
                // If it's visible and doesn't have success classes, it might be challenging
                if (style.display !== 'none' && !parent.classList.contains('cf-turnstile-success')) {
                  return true;
                }
              }
            }
          }

          // Also check for explicit challenge text or error messages
          const challengeText = document.querySelector('.cf-challenge-running, .cf-error-details');
          return challengeText !== null;
        });

        if (isTurnstileActive) {
          logger.error('Turnstile challenge is still active or failed');
          throw new Error('Turnstile CAPTCHA challenge failed');
        }

        throw new Error(
          `Login failed - still on login page with form present (URL: ${isStillOnLoginPage}, Form: ${loginFormPresent})`,
        );
      }

      // If we reach here, login was successful
      logger.info('Login validation passed - either URL changed or form elements removed');

      // If we're not on the login page anymore, check for successful login
      // First check common success indicators
      const successSelectors = [
        'a[href*="/user/"]',
        '.user-menu',
        '[data-testid="user-menu"]',
        '.js-user-menu',
        '.user-profile-link',
        'a[href*="/profile"]',
        '.user-nav',
      ];

      let loginSuccessful = false;
      for (const selector of successSelectors) {
        if (await this.page.$(selector)) {
          loginSuccessful = true;
          break;
        }
      }

      // Also check current URL for success indicators
      const currentUrl = this.page.url();
      if (
        currentUrl.includes('/user/') ||
        currentUrl.includes('/profile') ||
        currentUrl.includes('/dashboard') ||
        !currentUrl.includes('/login')
      ) {
        loginSuccessful = true;
      }

      if (loginSuccessful) {
        logger.info('Successfully logged into Chrono24');
        await cookieManager.saveCookies(this.page);
        this.isLoggedIn = true;
        this.lastActivity = Date.now();
        return true;
      }

      // If we can't find success indicators, wait a bit longer and try once more
      try {
        await this.page.waitForSelector('a[href*="/user/"], .user-menu, [data-testid="user-menu"], .js-user-menu', {
          timeout: 10000,
        });
        logger.info('Successfully logged into Chrono24 (delayed detection)');
        await cookieManager.saveCookies(this.page);
        this.isLoggedIn = true;
        this.lastActivity = Date.now();
        return true;
      } catch (e) {
        throw new Error('Login failed - could not verify successful login');
      }
    } catch (error) {
      logger.error('Login failed:', error.message);
      throw new Error(`Login failed: ${error.message}`);
    }
  }

  async handleTurnstileCaptcha() {
    try {
      // Check if Turnstile iframe is present
      const turnstileFrame = await this.page.$('iframe[src*="challenges.cloudflare.com"]');
      if (!turnstileFrame) {
        return; // No CAPTCHA present
      }

      logger.info('Turnstile CAPTCHA detected, attempting to handle...');

      // Wait for Turnstile to load
      await humanBehavior.randomDelay(2000, 4000);

      // Try to interact with the Turnstile checkbox
      try {
        const frame = await turnstileFrame.contentFrame();
        if (frame) {
          // Wait for the checkbox to appear
          await frame.waitForSelector('input[type="checkbox"], .cb-i, .ctp-checkbox-container', { timeout: 10000 });

          // Simulate human-like behavior before clicking
          await humanBehavior.randomDelay(1000, 2000);

          // Click the Turnstile checkbox
          const checkbox = await frame.$('input[type="checkbox"], .cb-i, .ctp-checkbox-container');
          if (checkbox) {
            await checkbox.click();
            logger.info('Clicked Turnstile checkbox');

            // Wait for verification
            await humanBehavior.randomDelay(3000, 6000);
          }
        }
      } catch (error) {
        logger.warn('Could not interact with Turnstile directly, attempting alternative approach');
      }

      // Alternative approach: simulate human-like mouse movements over the CAPTCHA area
      const turnstileBounds = await turnstileFrame.boundingBox();
      if (turnstileBounds) {
        // Move mouse to CAPTCHA area
        await this.page.mouse.move(
          turnstileBounds.x + turnstileBounds.width / 2,
          turnstileBounds.y + turnstileBounds.height / 2,
        );
        await humanBehavior.randomDelay(500, 1000);

        // Click in the CAPTCHA area
        await this.page.mouse.click(
          turnstileBounds.x + turnstileBounds.width / 2,
          turnstileBounds.y + turnstileBounds.height / 2,
        );

        logger.info('Clicked Turnstile CAPTCHA area');
      }
    } catch (error) {
      logger.warn('Error handling Turnstile CAPTCHA:', error.message);
    }
  }

  async waitForTurnstileCompletion() {
    try {
      // Wait for Turnstile to complete (either success or failure)
      await this.page.waitForFunction(
        () => {
          // Check for Turnstile completion indicators
          const turnstileContainer = document.querySelector('[data-sitekey], .cf-turnstile');
          if (!turnstileContainer) return true; // No Turnstile present

          // Check for success indicators
          const isSuccess =
            document.querySelector('.cf-turnstile[data-response]') ||
            document.querySelector('input[name="cf-turnstile-response"][value]') ||
            !document.querySelector('iframe[src*="challenges.cloudflare.com"]');

          return isSuccess;
        },
        { timeout: 30000, polling: 1000 },
      );

      logger.info('Turnstile challenge completed');
      await humanBehavior.randomDelay(1000, 2000);
    } catch (error) {
      logger.warn('Turnstile completion timeout or error:', error.message);
    }
  }

  async evaluateWatch(refNumber) {
    await this.initialize();
    await this.ensureLoggedIn();

    logger.info(`Starting watch evaluation for: ${refNumber}`);

    try {
      // Navigate to the watch collection page
      const collectionUrl =
        'https://www.chrono24.com/user/watch-collection/product-suggestions.htm?watchCollectionItemOrigin=WatchCollection';

      await this.page.goto(collectionUrl, {
        waitUntil: 'domcontentloaded',
        timeout: 45000,
      });

      // Human-like random delay
      await humanBehavior.randomDelay(2000, 4000);
      // Simulate human mouse movement and scroll
      const viewport = await this.page.viewport();
      await this.page.mouse.move(Math.random() * viewport.width, Math.random() * viewport.height);
      await this.page.evaluate(() => {
        window.scrollTo(0, Math.floor(Math.random() * 500));
      });
      await humanBehavior.randomDelay(1000, 2000);

      // Debug: log before waiting for selector
      logger.info('Waiting for search input selector: input[placeholder*="Brand, model, reference number"]');
      const searchSelector = 'input[placeholder*="Brand, model, reference number"]';
      let searchInputFound = false;
      try {
        await this.page.waitForSelector(searchSelector, { timeout: 15000 });
        searchInputFound = true;
        logger.info('Found search input using placeholder selector');
      } catch (e) {
        logger.warn('Could not find search input by placeholder, trying fallback by class');
        // Try fallback by class name
        const fallbackSelector = '.wt-add-funnel-searchbar-input';
        try {
          await this.page.waitForSelector(fallbackSelector, { timeout: 10000 });
          searchInputFound = true;
          logger.info('Found search input using class selector');
        } catch (e2) {
          logger.error('Could not find search input by class either. Dumping page HTML for debugging.');
          const pageHtml = await this.page.content();
          logger.error('PAGE HTML (truncated): ' + pageHtml.slice(0, 2000));
          throw new Error('Search input not found on Chrono24 page');
        }
      }

      // Use whichever selector worked
      const activeSearchSelector = searchInputFound
        ? (await this.page.$(searchSelector))
          ? searchSelector
          : '.wt-add-funnel-searchbar-input'
        : searchSelector;

      // Clear and enter search term
      await this.page.click(activeSearchSelector);
      await humanBehavior.randomDelay(500, 1000);

      // Clear existing content
      await this.page.keyboard.down('Control');
      await this.page.keyboard.press('KeyA');
      await this.page.keyboard.up('Control');
      await humanBehavior.randomDelay(100, 300);

      // Type the reference number
      await humanBehavior.humanType(this.page, activeSearchSelector, refNumber, false);
      await humanBehavior.randomDelay(1000, 2000);

      // Click search button
      const searchButtonSelector = 'button[type="button"] i.i-search';
      await this.page.waitForSelector(searchButtonSelector, { timeout: 5000 });
      await humanBehavior.humanClick(this.page, searchButtonSelector);

      // Wait for results to load
      await humanBehavior.randomDelay(3000, 5000);

      // Wait for and click the first result
      const firstResultSelector = '.watch-list-item:first-child';
      await this.page.waitForSelector(firstResultSelector, { timeout: 15000 });

      await humanBehavior.randomMouseMove(this.page);
      await humanBehavior.humanClick(this.page, firstResultSelector);

      // Wait for the details page to load
      await humanBehavior.randomDelay(2000, 4000);

      // First, record initial prices (before selecting "Worn")
      let initialPrices = null;
      try {
        const initialPriceContainer = '.price-container .h4';
        await this.page.waitForSelector(initialPriceContainer, { timeout: 10000 });
        initialPrices = await this.extractPriceRange();
        logger.info('Initial prices recorded:', initialPrices);
      } catch (e) {
        logger.warn('Could not extract initial prices');
      }

      // Find and click the "Worn" radio button
      const wornRadioSelector = 'input[type="radio"][value="worn"]';
      await this.page.waitForSelector(wornRadioSelector, { timeout: 10000 });

      await humanBehavior.randomDelay(1000, 2000);
      await humanBehavior.humanClick(this.page, wornRadioSelector);

      // Wait for prices to update after selecting "Worn"
      await humanBehavior.randomDelay(2000, 4000);

      // Verify the radio button was selected and prices changed
      let attempts = 0;
      const maxAttempts = 5;
      let finalPrices = null;

      while (attempts < maxAttempts) {
        try {
          // Check if radio button is selected
          const isSelected = await this.page.$eval(wornRadioSelector, (el) => el.checked);

          if (isSelected) {
            // Extract updated prices
            finalPrices = await this.extractPriceRange();

            // Verify prices have changed (if we had initial prices)
            if (
              !initialPrices ||
              finalPrices.minPrice !== initialPrices.minPrice ||
              finalPrices.maxPrice !== initialPrices.maxPrice
            ) {
              logger.info('Worn condition selected and prices updated:', finalPrices);
              break;
            }
          }

          // If not selected or prices haven't changed, try clicking again
          await humanBehavior.randomDelay(1000, 2000);
          await humanBehavior.humanClick(this.page, wornRadioSelector);
          await humanBehavior.randomDelay(2000, 3000);
        } catch (e) {
          logger.warn(`Attempt ${attempts + 1} failed to verify worn condition:`, e.message);
        }

        attempts++;
      }

      if (!finalPrices) {
        finalPrices = await this.extractPriceRange();
      }

      // Calculate target price (80% of minimum price)
      const result = priceCalculator.calculateTargetPrice(refNumber, finalPrices.minPrice, finalPrices.maxPrice);

      this.lastActivity = Date.now();
      logger.info(`Evaluation completed for ${refNumber}:`, result);

      return result;
    } catch (error) {
      logger.error(`Evaluation failed for ${refNumber}:`, error.message);
      throw error;
    }
  }

  async extractPriceRange() {
    try {
      // Wait for price container
      await this.page.waitForSelector('.price-container', { timeout: 5000 });

      // Extract price range
      const priceData = await this.page.evaluate(() => {
        const priceContainer = document.querySelector('.price-container .h4');
        if (!priceContainer) {
          throw new Error('Price container not found');
        }

        const priceText = priceContainer.textContent;
        const priceSpans = priceContainer.querySelectorAll('span');

        if (priceSpans.length >= 2) {
          const price1Text = priceSpans[0].textContent.replace(/[^0-9]/g, '');
          const price2Text = priceSpans[1].textContent.replace(/[^0-9]/g, '');

          const price1 = parseInt(price1Text);
          const price2 = parseInt(price2Text);

          return {
            minPrice: Math.min(price1, price2),
            maxPrice: Math.max(price1, price2),
            rawText: priceText,
          };
        } else {
          // Single price case
          const singlePrice = parseInt(priceText.replace(/[^0-9]/g, ''));
          return {
            minPrice: singlePrice,
            maxPrice: singlePrice,
            rawText: priceText,
          };
        }
      });

      return priceData;
    } catch (error) {
      logger.error('Failed to extract price range:', error.message);
      throw new Error(`Could not extract price information: ${error.message}`);
    }
  }

  async testConnection() {
    try {
      await this.initialize();

      const testUrl = 'https://www.chrono24.com';
      await this.page.goto(testUrl, {
        waitUntil: 'networkidle2',
        timeout: 30000,
      });

      const title = await this.page.title();

      return {
        status: 'connected',
        url: testUrl,
        title: title,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      throw new Error(`Connection test failed: ${error.message}`);
    }
  }

  async cleanup() {
    logger.info('Cleaning up browser resources');

    try {
      if (this.page && !this.page.isClosed()) {
        await this.page.close();
      }
    } catch (e) {
      logger.warn('Error closing page:', e.message);
    }

    try {
      if (this.browser && this.browser.isConnected()) {
        await this.browser.close();
      }
    } catch (e) {
      logger.warn('Error closing browser:', e.message);
    }

    this.browser = null;
    this.page = null;
    this.isLoggedIn = false;
  }
}

module.exports = new Chrono24Service();

module.exports = Chrono24Service;
